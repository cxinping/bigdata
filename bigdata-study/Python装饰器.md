
# 装饰器

装饰器用于在源码中“标记”函数，以增强函数的行为。

我们先来看下面的例子，现有一个求和函数add，现在要求统计函数执行的时长

```
def add(a, b):
    print(a+b)
```

常用做法
```
def add(a, b):
    start = time.time()
    print(a + b)
    time.sleep(2)#模拟耗时操作
    long = time.time() - start
    print(f'共耗时{long}秒。')
```

这样做可以实现需求，但是对原函数做了修改，不仅增加了耦合性，扩展和复用也变得难以实现。

假如再增加一个记录日志的功能以及对程序中所有的函数都进行时长统计，想想就可怕。

那好办啊，我们可以这样写：

```
def timer(func,*args):
    start = time.time()
    func(*args)
    time.sleep(2)#模拟耗时操作
    long = time.time() - start
    print(f'共耗时{long}秒。')

timer(add,1,2)
```

这样没有改变原函数吧？是的，但是改变了函数调用方式，每个调用add的地方都需要修改，这么做只是转嫁了矛盾而已。

又不能修改原函数，又不能改变调用方式，那该怎么办呢？装饰器是时候登场了。

在写装饰器之前先了解两个概念：高阶函数和闭包

高阶函数：接受函数为入参，或者把函数作为结果返回的函数。后者称之为嵌套函数。

闭包：指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。概念比较晦涩，简单来说就是嵌套函数引用了外层函数的变量。

嵌套函数和闭包可以理解为是同时存在的，上面的timer已经是高阶函数了，它接受函数作为入参，我们把它改造为嵌套函数实现装饰器：


















